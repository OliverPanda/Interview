### Node为什么要设计成异步？
后端事务处理和UI渲染会抢占进程, 同步的话可能导致UI渲染和响应停止，让人以为网页挂了

### Node异步编程的困扰
1. 异常处理难捕获 ---> 解决: 将异常信息作为回调的实参传回
2. 嵌套过深 ---> 解决: async
3. 无法阻塞代码 ---> 自己写sleep()


### Buffer
1. 对外内存，不是V8分配
2. 元素为16进制的两位数, 中文占3个元素, 字母和半角标点占一个元素
3. Buffer元素不在0-255的话，进行加减256换算， 不是整数则保留小数部分

### 进程 VS 线程
1. 程序至少一个进程， 一个进程至少一个线程
2. 进程崩溃，可以进程守护，影响不了主进程， 线程崩溃 => 所在进程崩溃
3. 总结： 进程健壮、快速， 线程切换比进程切换开销小，可以共享变量


### UDP VS TCP
UDP特点： 无需连接， 消耗低，网络差或者丢包的时候影响不大， **适用场景： 音视频**, DNS基于UDP实现， **可以一对多**, 基于报文

TCP特点： 一对一，传输完数据必须关闭连接， 基于字节流

### Node多进程
1. Master-Worker模式(主从模式)： 主进程不负责业务处理，只负责调度和管理工作进程（稳定的）， 工作进程处理具体业务
2. 进程通信： 主从: on('message'), 子进程间通信: sen(msg)到主 进程 -> 主进程转达 
3. 进程管理： 工作进程捕获异常 -> 工作进程自杀 -> 创建替补进程 -> 退出并删除异常进程， 负载均衡： 使用轮叫调度平均分配请求


### Node集群维护
1. 一个工作进程退出 -> 创建新的工作进程替补<br />
2. 有未捕获的异常出现 -> 进程异常 -> 工作进程向主进程发起自杀指令 -> 主进程创建新的进程，准备替补异常进程 -> 退出并删除异常进程<br />
3. 要设置连接超时，在长连接的时候才不会一直处于连接状态<br />
4. 假如某个工作进程异常了，然后在**重建新进程的过程中一直都出现异常**，那么工作进程就会一直无限重启。<br /> 为了预防这种情况，我们需要**设置一个工作进程单位时间内的重启最大次数**。 假如进程的重启次数超过了限定的重启次数，那么调用process.emit('giveup', length, during)，告知进程不再重启。 giveup事件十分严重，需要添加重要日志<br />
5. 负载均衡，多个进程之间监听相同的端口，使得用户请求分散到多个进程进行处理，能有效利用CPU资源。<br /> **Node中使用轮叫调度进行负载均衡**， 轮叫调度： 主进程接受请求 -> 依次分给工作进程，N个进程中，每次选择第i = (i + 1) mod n 个进程来发送链接，通过cluster模块启动轮叫调度， cluster.schedulingPolicy = cluster.SCHED<br />
6. 状态共享，因为node进程中不宜存放太多数据，会转化为老生代内存而存储到内存中, 加重垃圾回收负担。但是Node是不允许进程间共享数据的，所以状态共享用第三方库redis

### http vs https
1. https需要ca证书，进行加密传输，安全性高，在原生Node中依赖于TLS模块，和http模块相比多了证书信息的参数
2. 端口不一样, http端口80, https端口443

### http1.0 + http1.1 + http2.0
#### http1.1新增点: 
1. etags缓存控制头引入
2. 新增24个错误响应码
3. 长连接，默认开启Connection: keep-alive，keep-alive: 暂时保留TCP连接，降低tcp连接的建立次数次数

#### http2.0新增点: 
1. 二进制分帧: 将消息分割为更小的消息和帧，并转成二进制编码
2. 多路复用： 允许单一的HTTP2.0连接发起多重请求-响应消息
3. 服务端推送并且可缓存
4. HTTP首部压缩
